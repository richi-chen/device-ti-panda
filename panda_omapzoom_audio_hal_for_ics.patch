diff --git a/audio/Android.mk b/audio/Android.mk
index 4babe71..aaecdc0 100644
--- a/audio/Android.mk
+++ b/audio/Android.mk
@@ -22,6 +22,8 @@ else ifneq (,$(findstring blaze, $(TARGET_PRODUCT)))
     LOCAL_MODULE := audio.primary.blaze
 else ifneq (,$(findstring omap5sevm, $(TARGET_PRODUCT)))
     LOCAL_MODULE := audio.primary.omap5430evmboard
+else ifneq (,$(findstring panda, $(TARGET_PRODUCT)))
+    LOCAL_MODULE := audio.primary.panda
 else
     LOCAL_MODULE := audio.primary.generic
 endif
diff --git a/audio/audio_hw.c b/audio/audio_hw.c
index 64ada76..435930e 100644
--- a/audio/audio_hw.c
+++ b/audio/audio_hw.c
@@ -230,6 +230,7 @@
 #define PRODUCT_DEVICE_BLAZE    "blaze"
 #define PRODUCT_DEVICE_TABLET   "blaze_tablet"
 #define PRODUCT_DEVICE_OMAP5_SEVM   "omap5sevm"
+#define PRODUCT_DEVICE_PANDA    "richi-panda"
 
 /* fm */
 static bool fm_enable = false;
@@ -238,6 +239,7 @@ enum supported_boards {
     OMAP4_BLAZE,
     OMAP4_TABLET,
     OMAP5_SEVM,
+    PANDA
 };
 
 enum tty_modes {
@@ -831,6 +833,10 @@ static int get_boardtype(struct omap_audio_device *adev)
             adev->board_type = OMAP5_SEVM;
             adev->sidetone_capture = 1;
     }
+    else if(!strcmp(board, PRODUCT_DEVICE_PANDA)) {
+            adev->board_type = OMAP4_TABLET;
+            adev->sidetone_capture = 0;
+    }
     else
         return -EINVAL;
 
@@ -1193,6 +1199,14 @@ static void select_output_device(struct omap_audio_device *adev)
 
     LOGFUNC("%s(%p)", __FUNCTION__, adev);
 
+    if(adev->board_type ==  PANDA) {
+        headset_on = 0;
+        speaker_on = 1;
+        mixer_ctl_set_value(adev->mixer_ctls.mm_dl1, 0, 1);
+        set_route_by_array(adev->mixer, hs_output, 1);
+        set_input_volumes(adev, 0,
+                        headset_on, speaker_on);
+    } else {
     /* Mute VX_UL to avoid pop noises in the tx path
      * during call before switch changes.
      */
@@ -1352,6 +1366,7 @@ static void select_output_device(struct omap_audio_device *adev)
     }
 
     mixer_ctl_set_value(adev->mixer_ctls.sidetone_capture, 0, sidetone_capture_on);
+    }
 }
 
 static void select_input_device(struct omap_audio_device *adev)
@@ -1365,6 +1380,17 @@ static void select_input_device(struct omap_audio_device *adev)
 
     LOGFUNC("%s(%p)", __FUNCTION__, adev);
 
+    if(adev->board_type == PANDA) {
+        /*panda only supports headset mic */
+        main_mic_on = 0;
+        headset_on = 1;
+        sub_mic_on = 0;
+        set_route_by_array(adev->mixer, mm_ul2_amic_left, 1);
+        /* Select back end */
+        mixer_ctl_set_enum_by_string(adev->mixer_ctls.right_capture, MIXER_HS_MIC);
+        mixer_ctl_set_enum_by_string(adev->mixer_ctls.left_capture, MIXER_HS_MIC);
+        set_input_volumes(adev, main_mic_on, headset_on, sub_mic_on);
+    } else {
     if (!bt_on) {
         if ((adev->mode != AUDIO_MODE_IN_CALL) && (adev->active_input != 0)) {
             /* sub mic is used for camcorder or VoIP on speaker phone */
@@ -1429,6 +1455,7 @@ static void select_input_device(struct omap_audio_device *adev)
     adev->input_requires_stereo = hw_is_stereo_only;
 
     set_input_volumes(adev, main_mic_on, headset_on, sub_mic_on);
+    }
 }
 
 /* must be called with hw device and output stream mutexes locked */
@@ -1459,11 +1486,11 @@ static int start_output_stream(struct omap_stream_out *out)
         card = CARD_OMAP_HDMI;
         port = PORT_MM;
     }
-    if((adev->devices & AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET) ||
-        (adev->devices & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET)) {
-        card = CARD_OMAP_USB;
-        port = PORT_MM;
-    }
+//    if((adev->devices & AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET) ||
+//        (adev->devices & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET)) {
+//        card = CARD_OMAP_USB;
+//        port = PORT_MM;
+//    }
     /* default to low power:
      *  NOTE: PCM_NOIRQ mode is required to dynamically scale avail_min
      */
