diff --git a/hwc/Android.mk b/hwc/Android.mk
index 8cb9f6e..cca01c5 100644
--- a/hwc/Android.mk
+++ b/hwc/Android.mk
@@ -8,8 +8,7 @@ include $(CLEAR_VARS)
 LOCAL_PRELINK_MODULE := false
 LOCAL_ARM_MODE := arm
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/../vendor/lib/hw
-LOCAL_SHARED_LIBRARIES := liblog libEGL libcutils libutils libhardware libhardware_legacy libz \
-                          libion
+LOCAL_SHARED_LIBRARIES := liblog libEGL libcutils libutils libhardware libhardware_legacy libz
 LOCAL_SRC_FILES := hwc.c rgz_2d.c
 LOCAL_STATIC_LIBRARIES := libpng
 
@@ -17,16 +16,12 @@ LOCAL_MODULE_TAGS := optional
 
 LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
 LOCAL_CFLAGS := -DLOG_TAG=\"ti_hwc\"
-LOCAL_C_INCLUDES += external/libpng external/zlib \
-                    $(LOCAL_PATH)/../ion/
+LOCAL_C_INCLUDES += external/libpng external/zlib
 
 LOCAL_C_INCLUDES += \
     $(LOCAL_PATH)/../edid/inc
 LOCAL_SHARED_LIBRARIES += libedid
 
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/../libdsswb
-LOCAL_SHARED_LIBRARIES += libdsswbhal
-
 # LOG_NDEBUG=0 means verbose logging enabled
 # LOCAL_CFLAGS += -DLOG_NDEBUG=0
 include $(BUILD_SHARED_LIBRARY)
diff --git a/hwc/hwc.c b/hwc/hwc.c
index eb052fd..368f7c5 100644
--- a/hwc/hwc.c
+++ b/hwc/hwc.c
@@ -37,7 +37,6 @@
 
 #include <ui/S3DFormat.h>
 #include <edid_parser.h>
-#include <DSSWBHal.h>
 
 #include <linux/bltsville.h>
 
@@ -59,20 +58,17 @@
 #include "hal_public.h"
 #include "rgz_2d.h"
 
-#include <linux/ion.h>
-#include <linux/omap_ion.h>
-#include <ion.h>
-
 #define MAX_HW_OVERLAYS 4
-#define WB_OVERLAY 4
 #define NUM_NONSCALING_OVERLAYS 1
 #define HAL_PIXEL_FORMAT_BGRX_8888      0x1FF
 #define HAL_PIXEL_FORMAT_TI_NV12        0x100
 #define HAL_PIXEL_FORMAT_TI_NV12_PADDED 0x101
+//<<<<<<< HEAD
 #define HAL_PIXEL_FORMAT_TI_NV12_1D     0x102
+//=======
+//>>>>>>> parent of 695fbd1... hwc: get platform limits from dsscomp driver
 #define MAX_TILER_SLOT (16 << 20)
 #define DISPLAY_REFRESH_TIME_IN_NSEC    16000000
-#define NUM_EXT_DISPLAY_BACK_BUFFERS 2
 
 struct ext_transform_t {
     __u8 rotation : 3;          /* 90-degree clockwise rotations */
@@ -194,8 +190,6 @@ struct omap4_hwc_device {
 
     buffer_handle_t *buffers;
     int use_sgx;
-    int use_wb;
-    hwc_layer_t wb_layer;
     int swap_rb;
     unsigned int post2_layers; /* Buffers used with DSS pipes*/
     unsigned int post2_blit_buffers; /* Buffers used with blit */
@@ -215,9 +209,6 @@ struct omap4_hwc_device {
     struct omap_hwc_data comp_data; /* This is a kernel data structure */
     struct rgz_blt_entry blit_ops[RGZ_MAX_BLITS];
     struct counts stats;
-    int    ion_fd;
-    struct ion_handle *ion_handles[2];
-
 };
 typedef struct omap4_hwc_device omap4_hwc_device_t;
 
@@ -823,10 +814,32 @@ omap4_hwc_adjust_ext_layer(omap4_hwc_ext_t *ext, struct dss2_ovl_info *ovl)
         oc->mirror = !oc->mirror;
 }
 
-static struct dsscomp_platform_info limits;
+static struct dsscomp_dispc_limitations {
+    __u8 max_xdecim_2d;
+    __u8 max_ydecim_2d;
+    __u8 max_xdecim_1d;
+    __u8 max_ydecim_1d;
+    __u32 fclk;
+    __u8 max_downscale;
+    __u8 min_width;
+    __u16 integer_scale_ratio_limit;
+    __u16 max_width;
+    __u16 max_height;
+} limits = {
+    .max_xdecim_1d = 16,
+    .max_xdecim_2d = 16,
+    .max_ydecim_1d = 16,
+    .max_ydecim_2d = 2,
+    .fclk = 170666666,
+    .max_downscale = 4,
+    .min_width = 2,
+    .integer_scale_ratio_limit = 2048,
+    .max_width = 2048,
+    .max_height = 2048,
+};
 
 static int omap4_hwc_can_scale(__u32 src_w, __u32 src_h, __u32 dst_w, __u32 dst_h, int is_2d,
-                               struct dsscomp_display_info *dis, struct dsscomp_platform_info *limits,
+                               struct dsscomp_display_info *dis, struct dsscomp_dispc_limitations *limits,
                                __u32 pclk)
 {
     __u32 fclk = limits->fclk / 1000;
@@ -894,7 +907,7 @@ static int omap4_hwc_is_valid_layer(omap4_hwc_device_t *hwc_dev,
     if (!is_NV12(handle)) {
         if (layer->transform)
             return 0;
-        if (mem1d(handle) > limits.tiler1d_slot_size)
+        if (mem1d(handle) > MAX_TILER_SLOT)
             return 0;
     }
 
@@ -1190,7 +1203,7 @@ static int can_dss_render_all(omap4_hwc_device_t *hwc_dev, struct counts *num)
             num->scaled_layers <= num->max_scaling_overlays &&
             num->NV12 <= num->max_scaling_overlays &&
             /* fits into TILER slot */
-            num->mem <= limits.tiler1d_slot_size &&
+            num->mem <= MAX_TILER_SLOT &&
             /* we cannot clone non-NV12 transformed layers */
             (!tform || (num->NV12 == num->possible_overlay_layers) ||
             (num->NV12 && ext->current.docking)) &&
@@ -1241,21 +1254,8 @@ static int clone_layer(omap4_hwc_device_t *hwc_dev, int ix) {
     /* reserve overlays at end for other display */
     o->cfg.ix = MAX_HW_OVERLAYS - 1 - ext_ovl_ix;
     o->cfg.mgr_ix = 1;
-    /*
-    * Here the assumption is that overlay0 is the one attached to FB.
-    * Hence this clone_layer call is for FB cloning (provided use_sgx is true).
-    */
-    /* For the external displays whose transform is the same as
-    * that of primary display, ion_handles would be NULL hence
-    * the below logic doesn't execute.
-    */
-    if (ix == 0 && hwc_dev->ion_handles[sync_id%2] && hwc_dev->use_sgx) {
-        o->addressing = OMAP_DSS_BUFADDR_ION;
-        o->ba = (int)hwc_dev->ion_handles[sync_id%2];
-    } else {
-        o->addressing = OMAP_DSS_BUFADDR_OVL_IX;
-        o->ba = ix;
-    }
+    o->addressing = OMAP_DSS_BUFADDR_OVL_IX;
+    o->ba = ix;
 
     /* use distinct z values (to simplify z-order checking) */
     o->cfg.zorder += hwc_dev->post2_layers;
@@ -1466,16 +1466,12 @@ static int setup_mirroring(omap4_hwc_device_t *hwc_dev)
     return 0;
 }
 
-static void blit_reset(omap4_hwc_device_t *hwc_dev, int flags)
+static void blit_reset(omap4_hwc_device_t *hwc_dev)
 {
     hwc_dev->blit_flags = 0;
     hwc_dev->blit_num = 0;
     hwc_dev->post2_blit_buffers = 0;
     hwc_dev->comp_data.blit_data.rgz_items = 0;
-
-    /* We want to maintain the rgz dirty region data if there are no geometry changes */
-    if (flags & HWC_GEOMETRY_CHANGED)
-        rgz_release(&grgz);
 }
 
 static int blit_layers(omap4_hwc_device_t *hwc_dev, hwc_layer_list_t *list, int bufoff)
@@ -1484,6 +1480,10 @@ static int blit_layers(omap4_hwc_device_t *hwc_dev, hwc_layer_list_t *list, int
     if (!list || hwc_dev->force_sgx)
         goto err_out;
 
+    /* We want to maintain the rgz dirty region data if there are no geometry changes */
+    if (list->flags & HWC_GEOMETRY_CHANGED)
+        rgz_release(&grgz);
+
     int rgz_in_op;
     int rgz_out_op;
 
@@ -1524,12 +1524,14 @@ static int blit_layers(omap4_hwc_device_t *hwc_dev, hwc_layer_list_t *list, int
         }
     }
 
+    int needclear = (list->numHwLayers != count) ? 1 : 0;
+
     rgz_out_params_t out = {
         .op = rgz_out_op,
         .data = {
             .bvc = {
                 .dstgeom = &gscrngeom,
-                .noblend = 0,
+                .noblend = 0, .clrdst = needclear,
             }
         }
     };
@@ -1565,7 +1567,7 @@ static int blit_layers(omap4_hwc_device_t *hwc_dev, hwc_layer_list_t *list, int
     for (i = 0; i < list->numHwLayers; i++) {
         if (list->hwLayers[i].compositionType != HWC_OVERLAY) {
             list->hwLayers[i].compositionType = HWC_OVERLAY;
-            list->hwLayers[i].hints &= ~HWC_HINT_TRIPLE_BUFFER;
+            //LOGI("blitting layer %d", i);
         }
         list->hwLayers[i].hints &= ~HWC_HINT_CLEAR_FB;
     }
@@ -1590,47 +1592,6 @@ void debug_post2(omap4_hwc_device_t *hwc_dev, int nbufs)
     }
 }
 
-static int free_tiler2d_buffers(omap4_hwc_device_t *hwc_dev)
-{
-    int i;
-
-    for (i = 0 ; i < NUM_EXT_DISPLAY_BACK_BUFFERS; i++) {
-        ion_free(hwc_dev->ion_fd, hwc_dev->ion_handles[i]);
-        hwc_dev->ion_handles[i] = NULL;
-    }
-    return 0;
-}
-
-static int allocate_tiler2d_buffers(omap4_hwc_device_t *hwc_dev)
-{
-    int ret, i;
-    size_t stride;
-
-    if (hwc_dev->ion_fd < 0) {
-        LOGE("No ion fd, hence can't allocate tiler2d buffers");
-        return -1;
-    }
-
-    for (i = 0; i < NUM_EXT_DISPLAY_BACK_BUFFERS; i++) {
-        if (hwc_dev->ion_handles[i])
-            return 0;
-    }
-
-    for (i = 0 ; i < NUM_EXT_DISPLAY_BACK_BUFFERS; i++) {
-        ret = ion_alloc_tiler(hwc_dev->ion_fd, hwc_dev->fb_dev->base.width, hwc_dev->fb_dev->base.height,
-                                            TILER_PIXEL_FMT_32BIT, 0, &hwc_dev->ion_handles[i], &stride);
-        if (ret)
-            goto handle_error;
-
-        LOGI("ion handle[%d][%p]", i, hwc_dev->ion_handles[i]);
-    }
-    return 0;
-
-handle_error:
-    free_tiler2d_buffers(hwc_dev);
-    return -1;
-}
-
 static int omap4_hwc_prepare(struct hwc_composer_device *dev, hwc_layer_list_t* list)
 {
     omap4_hwc_device_t *hwc_dev = (omap4_hwc_device_t *)dev;
@@ -1669,7 +1630,7 @@ static int omap4_hwc_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
     int ix_s3d = -1;
 
     int blit_all = 0;
-    blit_reset(hwc_dev, list->flags);
+    blit_reset(hwc_dev);
 
     /* If the SGX is used or we are going to blit something we need a framebuffer
      * and a DSS pipe
@@ -1706,19 +1667,13 @@ static int omap4_hwc_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
              is_protected(layer) ||
              is_upscaled_NV12(hwc_dev, layer) ||
              (hwc_dev->ext.current.docking && hwc_dev->ext.current.enabled && dockable(layer))) &&
-            mem_used + mem1d(handle) < limits.tiler1d_slot_size &&
+            mem_used + mem1d(handle) < MAX_TILER_SLOT &&
             /* can't have a transparent overlay in the middle of the framebuffer stack */
             !(is_BLENDED(layer) && fb_z >= 0)) {
 
             /* render via DSS overlay */
             mem_used += mem1d(handle);
             layer->compositionType = HWC_OVERLAY;
-            /*
-             * This hint will not be used in vanilla ICS, but maybe in
-             * JellyBean, it is useful to distinguish between blts and true
-             * overlays
-             */
-            layer->hints |= HWC_HINT_TRIPLE_BUFFER;
 
             /* clear FB above all opaque layers if rendering via SGX */
             if (hwc_dev->use_sgx && !is_BLENDED(layer))
@@ -1889,38 +1844,7 @@ static int omap4_hwc_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
         z |= 1 << c->zorder;
         ix |= 1 << c->ix;
     }
-
-    // configure dsscomp for WB if any capture is pending
-    hwc_dev->use_wb = wb_capture_layer(&hwc_dev->wb_layer);
-    if (hwc_dev->use_wb) {
-        hwc_layer_t *layer = &hwc_dev->wb_layer;
-        IMG_native_handle_t *handle = (IMG_native_handle_t *)layer->handle;
-
-        layer->compositionType = HWC_OVERLAY;
-        hwc_dev->buffers[hwc_dev->post2_layers] = (buffer_handle_t)handle;
-
-        //dump_layer(layer);
-        omap4_hwc_setup_layer(hwc_dev,
-                              &dsscomp->ovls[dsscomp->num_ovls],
-                              layer,
-                              0, /* z-order doesn't matter for WB */
-                              handle->iFormat,
-                              handle->iWidth,
-                              handle->iHeight);
-
-        dsscomp->ovls[dsscomp->num_ovls].cfg.ix = WB_OVERLAY;
-        dsscomp->ovls[dsscomp->num_ovls].addressing = OMAP_DSS_BUFADDR_LAYER_IX;
-        dsscomp->ovls[dsscomp->num_ovls].ba = hwc_dev->post2_layers;
-        dsscomp->ovls[dsscomp->num_ovls].cfg.wb_source = OMAP_WB_LCD1;
-        dsscomp->ovls[dsscomp->num_ovls].cfg.wb_mode = OMAP_WB_CAPTURE_MODE;
-
-        dsscomp->num_ovls++;
-        dsscomp->mode = DSSCOMP_SETUP_DISPLAY_CAPTURE;
-        hwc_dev->post2_layers++;
-    } else {
-        dsscomp->mode = DSSCOMP_SETUP_DISPLAY;
-    }
-
+    dsscomp->mode = DSSCOMP_SETUP_DISPLAY;
     dsscomp->mgrs[0].ix = 0;
     dsscomp->mgrs[0].alpha_blending = 1;
     dsscomp->mgrs[0].swap_rb = hwc_dev->swap_rb;
@@ -1934,7 +1858,7 @@ static int omap4_hwc_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
     }
 
     if (debug) {
-        LOGD("prepare (%d) - %s (comp=%d, poss=%d/%d scaled, RGB=%d,BGR=%d,NV12=%d) (ext=%s%s%ddeg%s %dex/%dmx (last %dex,%din) wb=%d\n",
+        LOGD("prepare (%d) - %s (comp=%d, poss=%d/%d scaled, RGB=%d,BGR=%d,NV12=%d) (ext=%s%s%ddeg%s %dex/%dmx (last %dex,%din)\n",
              dsscomp->sync_id,
              hwc_dev->use_sgx ? "SGX+OVL" : "all-OVL",
              num.composited_layers,
@@ -1944,7 +1868,7 @@ static int omap4_hwc_prepare(struct hwc_composer_device *dev, hwc_layer_list_t*
              ext->current.enabled ? ext->current.docking ? "dock+" : "mirror+" : "OFF+",
              ext->current.rotation * 90,
              ext->current.hflip ? "+hflip" : "",
-             hwc_dev->ext_ovls, num.max_hw_overlays, hwc_dev->last_ext_ovls, hwc_dev->last_int_ovls, hwc_dev->use_wb);
+             hwc_dev->ext_ovls, num.max_hw_overlays, hwc_dev->last_ext_ovls, hwc_dev->last_int_ovls);
     }
 
     pthread_mutex_unlock(&hwc_dev->lock);
@@ -1993,8 +1917,6 @@ static int omap4_hwc_set(struct hwc_composer_device *dev, hwc_display_t dpy,
 
     invalidate = hwc_dev->ext_ovls_wanted && (hwc_dev->ext_ovls < hwc_dev->ext_ovls_wanted) &&
                                               (hwc_dev->stats.protected || !hwc_dev->ext_ovls);
-    // hwc_prepare needs to be called again if any capture with WB is pending
-    invalidate |= wb_capture_pending();
 
     if (debug)
         dump_set_info(hwc_dev, list);
@@ -2074,15 +1996,9 @@ static int omap4_hwc_set(struct hwc_composer_device *dev, hwc_display_t dpy,
         have_last = 1;
         clock_gettime(CLOCK_MONOTONIC, &last_set_time);
         showfps();
-
-        if (hwc_dev->use_wb) {
-            wb_capture_started(hwc_dev->wb_layer.handle);
-        }
     }
     hwc_dev->last_ext_ovls = hwc_dev->ext_ovls;
-    // remove wb from the count of overlays used for composition
-    hwc_dev->last_int_ovls = hwc_dev->post2_layers - hwc_dev->use_wb;
-
+    hwc_dev->last_int_ovls = hwc_dev->post2_layers;
     if (err)
         LOGE("Post2 error");
 
@@ -2257,9 +2173,6 @@ static int omap4_hwc_device_close(hw_device_t* device)
             close(hwc_dev->hdmi_fb_fd);
         if (hwc_dev->fb_fd >= 0)
             close(hwc_dev->fb_fd);
-        if (hwc_dev->ion_fd >= 0)
-            ion_close(hwc_dev->ion_fd);
-
         /* pthread will get killed when parent process exits */
         pthread_mutex_destroy(&hwc_dev->lock);
         free(hwc_dev);
@@ -2397,19 +2310,8 @@ static void handle_hotplug(omap4_hwc_device_t *hwc_dev)
             } else
                 ext->mirror.enabled = 0;
         }
-        /* Allocate backup buffers for FB rotation
-        * This is required only if the FB tranform is different from that
-        * of the external display and the FB is not in TILER2D space
-        */
-        if (ext->mirror.rotation && (limits.fbmem_type != DSSCOMP_FBMEM_TILER2D))
-            allocate_tiler2d_buffers(hwc_dev);
-
     } else {
         ext->last_mode = 0;
-        if (ext->mirror.rotation && (limits.fbmem_type != DSSCOMP_FBMEM_TILER2D)) {
-            /* free tiler 2D buffer on detach */
-            free_tiler2d_buffers(hwc_dev);
-        }
     }
     LOGI("external display changed (state=%d, mirror={%s tform=%ddeg%s}, dock={%s tform=%ddeg%s%s}, tv=%d", state,
          ext->mirror.enabled ? "enabled" : "disabled",
@@ -2571,13 +2473,6 @@ static int omap4_hwc_device_open(const hw_module_t* module, const char* name,
         goto done;
     }
 
-    int ret = ioctl(hwc_dev->dsscomp_fd, DSSCIOC_QUERY_PLATFORM, &limits);
-    if (ret) {
-        LOGE("failed to get platform limits (%d): %m", errno);
-        err = -errno;
-        goto done;
-    }
-
     hwc_dev->fb_fd = open("/dev/graphics/fb0", O_RDWR);
     if (hwc_dev->fb_fd < 0) {
         LOGE("failed to open fb (%d)", errno);
@@ -2607,23 +2502,13 @@ static int omap4_hwc_device_open(const hw_module_t* module, const char* name,
         goto done;
     }
 
-    ret = ioctl(hwc_dev->dsscomp_fd, DSSCIOC_QUERY_DISPLAY, &hwc_dev->fb_dis);
+    int ret = ioctl(hwc_dev->dsscomp_fd, DSSCIOC_QUERY_DISPLAY, &hwc_dev->fb_dis);
     if (ret) {
         LOGE("failed to get display info (%d): %m", errno);
         err = -errno;
         goto done;
     }
 
-    hwc_dev->ion_fd = ion_open();
-    if (hwc_dev->ion_fd < 0) {
-        LOGE("failed to open ion driver (%d)", errno);
-    }
-
-    int i;
-    for (i = 0; i < NUM_EXT_DISPLAY_BACK_BUFFERS; i++) {
-        hwc_dev->ion_handles[i] = NULL;
-    }
-
     /* use default value in case some of requested display parameters missing */
     hwc_dev->ext.lcd_xpy = 1.0;
     if (hwc_dev->fb_dis.timings.x_res && hwc_dev->fb_dis.height_in_mm) {
@@ -2704,8 +2589,6 @@ static int omap4_hwc_device_open(const hw_module_t* module, const char* name,
     }
     handle_hotplug(hwc_dev);
 
-    wb_open();
-
     LOGI("omap4_hwc_device_open(rgb_order=%d nv12_only=%d)",
         hwc_dev->flags_rgb_order, hwc_dev->flags_nv12_only);
 
@@ -2714,7 +2597,7 @@ static int omap4_hwc_device_open(const hw_module_t* module, const char* name,
         LOGI("Unable to open gc-core device (%d), blits disabled", errno);
         hwc_dev->blt_policy = BLTPOLICY_DISABLED;
     } else {
-        property_get("persist.hwc.bltmode", value, "1");
+        property_get("persist.hwc.bltmode", value, "0");
         hwc_dev->blt_mode = atoi(value);
         property_get("persist.hwc.bltpolicy", value, "1");
         hwc_dev->blt_policy = atoi(value);
diff --git a/hwc/rgz_2d.c b/hwc/rgz_2d.c
index 8617028..cb71a0c 100644
--- a/hwc/rgz_2d.c
+++ b/hwc/rgz_2d.c
@@ -103,8 +103,6 @@ static int rgz_blts_bvdirect(rgz_t* rgz, struct rgz_blts *blts, rgz_out_params_t
 
 int debug = 0;
 struct rgz_blts blts;
-/* Represents a screen sized background layer */
-static hwc_layer_t bg_layer;
 
 static void svgout_header(int htmlw, int htmlh, int coordw, int coordh)
 {
@@ -287,11 +285,13 @@ static int rgz_out_bvdirect_paint(rgz_t *rgz, rgz_out_params_t *params)
 }
 
 /*
- * Clear the destination buffer, if rect is NULL means the whole screen, rect
- * cannot be outside the boundaries of the screen
+ * Clear the destination buffer
  */
-static void rgz_out_clrdst(rgz_out_params_t *params, blit_rect_t *rect)
+static void rgz_out_clrdst(rgz_t *rgz, rgz_out_params_t *params)
 {
+    if (!params->data.bvc.clrdst)
+        return;
+
     struct bvsurfgeom *scrgeom = params->data.bvc.dstgeom;
 
     struct rgz_blt_entry* e;
@@ -323,15 +323,18 @@ static void rgz_out_clrdst(rgz_out_params_t *params, blit_rect_t *rect)
     struct bvbltparams *bp = &e->bp;
     bp->structsize = sizeof(struct bvbltparams);
     bp->dstgeom = dstgeom;
+    bp->dstrect.left = 0;
+    bp->dstrect.top = 0;
+    bp->dstrect.width = scrgeom->width;
+    bp->dstrect.height = scrgeom->height;
     bp->src1.desc = src1desc;
     bp->src1geom = src1geom;
     bp->src1rect.left = 0;
     bp->src1rect.top = 0;
     bp->src1rect.width = bp->src1rect.height = 1;
-    bp->cliprect.left = bp->dstrect.left = rect ? rect->left : 0;
-    bp->cliprect.top = bp->dstrect.top = rect ? rect->top : 0;
-    bp->cliprect.width = bp->dstrect.width = rect ? (unsigned int) WIDTH(*rect) : scrgeom->width;
-    bp->cliprect.height = bp->dstrect.height = rect ? (unsigned int) HEIGHT(*rect) : scrgeom->height;
+    bp->cliprect.left = bp->cliprect.top = 0;
+    bp->cliprect.width = scrgeom->width;
+    bp->cliprect.height = scrgeom->height;
 
     bp->flags = BVFLAG_CLIP | BVFLAG_ROP;
     bp->op.rop = 0xCCCC; /* SRCCOPY */
@@ -343,7 +346,7 @@ static int rgz_out_bvcmd_paint(rgz_t *rgz, rgz_out_params_t *params)
     params->data.bvc.out_blits = 0;
     params->data.bvc.out_nhndls = 0;
     rgz_blts_init(&blts);
-    rgz_out_clrdst(params, NULL);
+    rgz_out_clrdst(rgz, params);
 
     unsigned int i;
     for (i = 0; i < rgz->rgz_layerno; i++) {
@@ -560,8 +563,6 @@ static int rgz_in_hwccheck(rgz_in_params_t *p, rgz_t *rgz)
     hwc_layer_t *layers = p->data.hwc.layers;
     int layerno = p->data.hwc.layerno;
 
-    rgz->state &= ~RGZ_STATE_INIT;
-
     if (!layers)
         return -1;
 
@@ -580,16 +581,12 @@ static int rgz_in_hwccheck(rgz_in_params_t *p, rgz_t *rgz)
 
     int possible_blit = 0, candidates = 0;
     rgz->screen_isdirty = 1;
-
-    /* Insert the background layer at the beginning of the list */
-    rgz->rgz_layers[0].hwc_layer = &bg_layer;
-
     for (l = 0; l < layerno; l++) {
         if (layers[l].compositionType == HWC_FRAMEBUFFER) {
             candidates++;
             if (rgz_in_valid_hwc_layer(&layers[l]) &&
-                    possible_blit < RGZ_INPUT_MAXLAYERS) {
-                rgz_layer_t *rgz_layer = &rgz->rgz_layers[possible_blit+1];
+                    possible_blit < RGZ_MAXLAYERS) {
+                rgz_layer_t *rgz_layer = &rgz->rgz_layers[possible_blit];
                 rgz_layer->hwc_layer = &layers[l];
                 rgz_layer->buffidx = memidx++;
                 if (rgz_layer->hwc_layer->handle != rgz_layer->dirty_hndl) {
@@ -597,8 +594,9 @@ static int rgz_in_hwccheck(rgz_in_params_t *p, rgz_t *rgz)
                     rgz_layer->dirty_hndl = (void*)rgz_layer->hwc_layer->handle;
                 } else {
                      rgz_layer->dirty_count -= rgz_layer->dirty_count ? 1 : 0;
+                     /* If a layer is not dirty don't clean the whole screen */
                      if (rgz_layer->dirty_count == 0)
-                         rgz->screen_isdirty = 0; /* Just update dirty regions from now on */
+                         rgz->screen_isdirty = 0;
                 }
                 possible_blit++;
             }
@@ -609,8 +607,8 @@ static int rgz_in_hwccheck(rgz_in_params_t *p, rgz_t *rgz)
         return -1;
     }
 
-    rgz->state |= RGZ_STATE_INIT;
-    rgz->rgz_layerno = possible_blit + 1; /* Account for background layer */
+    rgz->state = RGZ_STATE_INIT;
+    rgz->rgz_layerno = possible_blit;
 
     return RGZ_ALL;
 }
@@ -622,16 +620,10 @@ static int rgz_in_hwc(rgz_in_params_t *p, rgz_t *rgz)
     int screen_width = p->data.hwc.dstgeom->width;
     int screen_height = p->data.hwc.dstgeom->height;
 
-    if (!(rgz->state & RGZ_STATE_INIT)) {
+    if (rgz->state != RGZ_STATE_INIT) {
         OUTE("rgz_process started with bad state");
         return -1;
     }
-
-    /* If there is already region data avoid parsing it again */
-    if (rgz->state & RGZ_REGION_DATA) {
-        return 0;
-    }
-
     int layerno = rgz->rgz_layerno;
 
     /* Find the horizontal regions */
@@ -644,10 +636,8 @@ static int rgz_in_hwc(rgz_in_params_t *p, rgz_t *rgz)
     rgz->nhregions = ylen - 1;
 
     blit_hregion_t *hregions = calloc(rgz->nhregions, sizeof(blit_hregion_t));
-    if (!hregions) {
-        OUTE("Unable to allocate memory for hregions");
+    if (!hregions)
         return -1;
-    }
     rgz->hregions = hregions;
 
     LOGD_IF(debug, "Allocated %d regions (sz = %d), layerno = %d", rgz->nhregions, rgz->nhregions * sizeof(blit_hregion_t), layerno);
@@ -1137,7 +1127,7 @@ static void rgz_batch_entry(struct rgz_blt_entry* e, unsigned int flag, unsigned
     e->bp.batchflags |= set;
 }
 
-static int rgz_hwc_subregion_blit(blit_hregion_t *hregion, int sidx, rgz_out_params_t *params, int screen_isdirty)
+static int rgz_hwc_subregion_blit(blit_hregion_t *hregion, int sidx, rgz_out_params_t *params)
 {
     static int loaded = 0;
     if (!loaded)
@@ -1159,29 +1149,8 @@ static int rgz_hwc_subregion_blit(blit_hregion_t *hregion, int sidx, rgz_out_par
 
     int lix;
     int ldepth = get_layer_ops(hregion, sidx, &lix);
-    if (ldepth == 0) {
-        /* Impossible, there are no layers in this region even if the
-         * background is covering the whole screen
-         */
-        OUTE("hregion %p subregion %d doesn't have any ops", hregion, sidx);
-        return -1;
-    }
-
-    /* Check if the bottom layer is the background */
-    if (hregion->rgz_layers[lix]->hwc_layer == &bg_layer) {
-        if (ldepth == 1) {
-            /* Background layer is the only operation, clear subregion */
-            if (screen_isdirty)
-                rgz_out_clrdst(params, &hregion->blitrects[lix][sidx]);
-            return 0;
-        } else {
-            /* No need to generate blits with background layer if there is
-             * another layer on top of it, discard it
-             */
-            ldepth--;
-            lix = get_layer_ops_next(hregion, sidx, lix);
-        }
-    }
+    if (ldepth == 0) /* No layers in subregion */
+        return 0;
 
     /* Determine if this region is dirty */
     int dirty = 0, dirtylix = lix;
@@ -1334,24 +1303,25 @@ static int rgz_out_region(rgz_t *rgz, rgz_out_params_t *params)
     rgz_blts_init(&blts);
     LOGD_IF(debug, "rgz_out_region:");
 
-    if (IS_BVCMD(params))
+    if (IS_BVCMD(params)) {
         params->data.bvc.out_blits = 0;
+        /* There is no need to clean the screen if it is not completely dirty,
+         * only dirty subregions need to update themselves (generate blits)
+         */
+        if (rgz->screen_isdirty)
+            rgz_out_clrdst(rgz, params);
+    }
 
     int i;
     for (i = 0; i < rgz->nhregions; i++) {
         blit_hregion_t *hregion = &rgz->hregions[i];
         int s;
         LOGD_IF(debug, "h[%d] nsubregions = %d", i, hregion->nsubregions);
-        if (hregion->nlayers == 0) {
-            /* Impossible, there are no layers in this region even if the
-             * background is covering the whole screen
-             */
-            OUTE("hregion %p doesn't have any ops", hregion);
-            return -1;
-        }
+        if (hregion->nlayers == 0)
+            continue;
         for (s = 0; s < hregion->nsubregions; s++) {
             LOGD_IF(debug, "h[%d] -> [%d]", i, s);
-            rgz_hwc_subregion_blit(hregion, s, params, rgz->screen_isdirty);
+            rgz_hwc_subregion_blit(hregion, s, params);
         }
     }
 
@@ -1360,10 +1330,9 @@ static int rgz_out_region(rgz_t *rgz, rgz_out_params_t *params)
     if (IS_BVCMD(params)) {
         unsigned int j;
         params->data.bvc.out_nhndls = 0;
-        /* Begin from index 1 to remove the background layer from the output */
-        for (j = 1; j < rgz->rgz_layerno; j++) {
+        for (j = 0; j < rgz->rgz_layerno; j++) {
             hwc_layer_t *layer = rgz->rgz_layers[j].hwc_layer;
-            params->data.bvc.out_hndls[j-1] = layer->handle;
+            params->data.bvc.out_hndls[j] = layer->handle;
             params->data.bvc.out_nhndls++;
         }
 
@@ -1463,10 +1432,6 @@ int rgz_get_screengeometry(int fd, struct bvsurfgeom *geom, int fmt)
         return -EINVAL;
     }
 
-    bg_layer.displayFrame.left = bg_layer.displayFrame.top = 0;
-    bg_layer.displayFrame.right = fb_varinfo.xres;
-    bg_layer.displayFrame.bottom = fb_varinfo.yres;
-
     bzero(geom, sizeof(*geom));
     geom->structsize = sizeof(*geom);
     geom->width = fb_varinfo.xres;
@@ -1477,14 +1442,30 @@ int rgz_get_screengeometry(int fd, struct bvsurfgeom *geom, int fmt)
     return 0;
 }
 
+/* Reset the values needed for every frame, except the dirty region handles */
+static void rgz_reset(rgz_t *rgz){
+    if (!rgz)
+        return;
+    if (rgz->hregions)
+        free(rgz->hregions);
+    rgz->hregions = NULL;
+    rgz->nhregions = 0;
+    rgz->state = 0;
+}
+
 int rgz_in(rgz_in_params_t *p, rgz_t *rgz)
 {
     int rv = -1;
     switch (p->op) {
     case RGZ_IN_HWC:
-        rv = rgz_in_hwccheck(p, rgz);
-        if (rv == RGZ_ALL)
-            rv = rgz_in_hwc(p, rgz) ? 0 : RGZ_ALL;
+        rgz_reset(rgz);
+        int chk = rgz_in_hwccheck(p, rgz);
+        if (chk == RGZ_ALL)  {
+            int rv = rgz_in_hwc(p, rgz);
+            if (rv != 0)
+                return rv;
+        }
+        rv = chk;
         break;
     case RGZ_IN_HWCCHK:
         bzero(rgz, sizeof(rgz_t));
@@ -1500,9 +1481,9 @@ void rgz_release(rgz_t *rgz)
 {
     if (!rgz)
         return;
-    if (rgz->hregions)
-        free(rgz->hregions);
-    bzero(rgz, sizeof(*rgz));
+    rgz_reset(rgz);
+    rgz->rgz_layerno = 0;
+    bzero(rgz->rgz_layers, sizeof(rgz->rgz_layers));
 }
 
 int rgz_out(rgz_t *rgz, rgz_out_params_t *params)
diff --git a/hwc/rgz_2d.h b/hwc/rgz_2d.h
index 4b4d3fb..e511435 100644
--- a/hwc/rgz_2d.h
+++ b/hwc/rgz_2d.h
@@ -18,18 +18,7 @@
 
 #include <linux/bltsville.h>
 
-/*
- * Maximum number of layers used to generate subregion rectangles in a
- * horizontal region.
- */
-#define RGZ_MAXLAYERS 13
-
-/*
- * Maximum number of layers the regionizer will accept as input. Account for an
- * additional 'background layer' to generate empty subregion rectangles.
- */
-#define RGZ_INPUT_MAXLAYERS (RGZ_MAXLAYERS - 1)
-
+#define RGZ_MAXLAYERS 12
 /*
  * Regionizer data
  *
@@ -111,7 +100,8 @@ struct rgz_out_bvcmd {
     int cmdlen;
     struct bvsurfgeom *dstgeom;
     int noblend;
-    buffer_handle_t out_hndls[RGZ_INPUT_MAXLAYERS]; /* OUTPUT */
+    int clrdst;
+    buffer_handle_t out_hndls[RGZ_MAXLAYERS]; /* OUTPUT */
     int out_nhndls; /* OUTPUT */
     int out_blits; /* OUTPUT */
 };
@@ -168,6 +158,7 @@ typedef struct rgz_out_params {
  * data.bvc.cmdlen      length of cmdp
  * data.bvc.dstgeom     bltsville struct describing the destination geometry
  * data.bvc.noblend     Test option to disable blending
+ * data.bvc.clrdst      Clear the destination
  * data.bvc.out_hndls   Array of buffer handles (OUTPUT)
  * data.bvc.out_nhndls  Number of buffer handles (OUTPUT)
  * data.bvc.out_blits   Number of blits (OUTPUT)
